from urllib import request
from json import dumps as jsonMarshal, loads as jsonUnMarshal
from re import Match as rMatch, search as rSearch
from argparse import ArgumentParser

XOR_KEY = ""
SEC_CHAR_POOL = ""


def get_XOR_KEY_SEC_CHAR_POOL(url: str = "http://192.168.0.1/web-static/dynaform/class.js"):
  '''
  This function will get a javascript file which includes the `XOR_KEY` and `SEC_CHAR_POOL`.
  Seemed like that the files in the `/web-static/dynaform` are generated by manufacturer
  when the firmware burn to the router.

  I used a regular expression to find them and set them to the constants.
  '''
  js_raw = request.urlopen(request.Request(url)).read()
  res = rSearch(r"securityEncode\(.+?\)", js_raw.decode("utf-8"))
  if type(res) == rMatch:
    _tuple = tuple(i for i in map(lambda x: x.replace('"', ""), res.group(
    ).removeprefix("securityEncode(").removesuffix(")").split(",")[1:]))
    if len(_tuple) == 2:
      global XOR_KEY
      global SEC_CHAR_POOL
      XOR_KEY = _tuple[0]
      SEC_CHAR_POOL = _tuple[1]


def encrypt(p: str) -> str:
  '''
  The core of this reverse. Get char from SEC_CHAR_POOL as encrypted char. Index of them is like `(ord(x[0])^ord(x[1]))%len(SEC_CHAR_POOL)`.

  I used some map functions for speeding up here. 
  '''
  if len(p) == len(XOR_KEY):
    return "".join(map(lambda x: SEC_CHAR_POOL[(ord(x[0]) ^ ord(x[1])) % len(SEC_CHAR_POOL)], zip(p, XOR_KEY)))
  elif len(p) > len(XOR_KEY):
    return "".join(map(lambda x: SEC_CHAR_POOL[(ord(x[0]) ^ ord(x[1])) % len(SEC_CHAR_POOL)], zip(p, XOR_KEY)))+"".join(map(lambda x: SEC_CHAR_POOL[(187 ^ ord(x)) % len(SEC_CHAR_POOL)], p[len(XOR_KEY):]))
  else:
    return "".join(map(lambda x: SEC_CHAR_POOL[(ord(x[0]) ^ ord(x[1])) % len(SEC_CHAR_POOL)], zip(p, XOR_KEY)))+"".join(map(lambda x: SEC_CHAR_POOL[(187 ^ ord(x)) % len(SEC_CHAR_POOL)], XOR_KEY[len(p):]))


def login(password: str, loginUrl: str = "http://192.168.0.1"):
  '''
  A simple login, do POST on the entry point of router with {"method":"do","login":"xxxxxxxx"}

  Router will return a json which likes {"error_code":0, "stok":"xxxxxxxxxxxxx"}.
  It is not success when error_code is not 0.
  You can operate router as rpc with the entry which is at "http://{router_entry}/stok={stok}/ds".
  As the calling method, you can capture from devtools of chrome-like browser.
  '''
  data = jsonMarshal(
      {"method": "do", "login": {"password": encrypt(password)}}).encode("utf-8")
  return jsonUnMarshal(request.urlopen(request.Request(loginUrl, data=data)).read())


if __name__ == "__main__":

  args_parser = ArgumentParser("A login method pwn of TP-Link")
  args_parser.add_argument("-p", "--password", type=str,
                           required=True, help="the admin password of TP-Link router")
  args_parser.add_argument("-ce", "--class-js-entry", type=str,
                           required=False, default=None, help="the class.js entry of router")
  args_parser.add_argument("-le", "--login-entry", type=str,
                           required=False, default=None, help="the login entry of router")
  args = args_parser.parse_args()

  if args.class_js_entry == None:
    get_XOR_KEY_SEC_CHAR_POOL()
  else:
    get_XOR_KEY_SEC_CHAR_POOL(args.class_js_entry)

  login_stok = None
  if args.login_entry == None:
    login_stok = login(args.password)
  else:
    login_stok = login(args.password, args.login_entry)

  print(jsonMarshal(login_stok, indent=2))
